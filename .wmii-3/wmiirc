#!/usr/bin/env ruby
# Copyright (c) 2006 Mauricio Fernandez <mfp@acm.org> 
#      http://eigenclass.org/hiki.rb?wmii+ruby
# Licensed under the same terms as Ruby (see LICENSE).

USE_IXP_EXTENSION = true
WMIIRC_VERSION = "0.3.0"
WMIIRC_RELEASE_DATE = "unreleased (preliminary/internal)"
WMIIRC_HOME = File.join(ENV["HOME"], ".wmii-3")
WMIIRC_CONFIG_FILE = File.join(WMIIRC_HOME, "wmiirc-config.rb")
WMIIRC_PLUGIN_DIR = File.join(WMIIRC_HOME, "plugins")

WMIIRC_HELP_MESSAGE = <<EOF

Welcome to ruby-wmii, a Ruby script for configuring and controlling the wmii
window manager. This message describes how you can customize and extend 
ruby-wmii. You can reread it at any time by pressing MODKEY-a and selecting
'config-help' (MODKEY is the Alt key by default).

Since 0.3.0, ruby-wmii can be customized by editing
  #{WMIIRC_CONFIG_FILE}
This makes upgrades easier, since you can overwrite the wmiirc script with a
newer version while all your settings are preserved in
#{WMIIRC_CONFIG_FILE}
In other words, the main wmiirc script itself shouldn't be modified. Were that
necessary, please consider submitting a patch if you think the changes will be
of use to other people. You can send your modifications to <mfp@acm.org> (add
'wmii' to the subject to make sure it gets through the spam filters).

Staying up to date
==================

The latest version of ruby-wmii can be obtained from
      http://eigenclass.org/hiki.rb?wmii+ruby
Run the included install.rb script with
  ruby install.rb
to install wmiirc and the standard plugin.
Were any further step necessary, it'd be noted in README.upgrade.

Using plugins
=============

ruby-wmii can be extended using third-party plugins comprising keyboard
bindings and "bar applets". This involves two steps:
1) placing the plugin under #{WMIIRC_PLUGIN_DIR}
2) editing #{WMIIRC_CONFIG_FILE} to request that a given plugin be used

Each plugin defines a number of key bindings and applets under a namespace.
A namespace:name pair refers to a key binding or an applet; this is all you
need to reference and use them.
Here's a small example of how to use the 'volume' applet and a number of
bindings defined under the "standard" namespace

  from("standard") {
    use_bar_applet("volume")
    use_binding("dict-lookup")
    use_binding("execute-program-with-tag")
    use_binding("execute-action")
    use_binding("execute-program")
    (0..9).each{|k| use_binding("numeric-jump-\#{k}") }
  }

This is broadly equivalent to
  
    use_bar_applet("standard:volume")
    use_binding("standard:dict-lookup")
    use_binding("standard:execute-program-with-tag")
    use_binding("standard:execute-action")
    use_binding("standard:execute-program")
    (0..9).each{|k| use_binding("standard:numeric-jump-\#{k}") }
    
(There's a small difference though: #from uses instance_eval to change self in
the block, but this shouldn't matter normally.)

Overriding default plugin settings
----------------------------------

The default position and the data (label displayed by wmiibar) of each bar
applet are specified by the author, but you can override them with something
like

   # override position only
   use_bar_applet("somebody@example.com:cool-bar-applet", 50)
   # position and label
   use_bar_applet("somebody@example.com:cool-bar-applet2", 100, "text to display")

the second argument should be an integer between 0 and 999, which will be used
to determine the relative position of the applets in use.

You can as well override the default key combination for a key binding (allowing 
you to reuse the action while changing the actual key sequence that triggers it)
as follows:

   use_binding("myfriend@example.com:do-magic", "MODKEY2-m", "MODKEY-Shift-m")

This associates the action defined as 'do-magic' under the myfriend@example
namespace to both MODKEY2 and MODKEY-Shift-m.

Further configuration
---------------------

Some plugins can be configured via the plugin_config hash.
See the default
  #{WMIIRC_CONFIG_FILE} 
for an example.

Read standard-plugin.rb to see the options accepted by the standard
bindings/applets. 

Writing your own plugins
========================

If you think you've found a particularly useful action or applet, you can 
distribute it as a plugin which should look like this:

  Plugin.define("my-email@address.com") do
    # Use your email address to make sure namespaces are unique.
    # You can also use  my-email@address.com/subspace  if you need to
    # partition your namespace.
    author '"My Full Name" <my-email-address.com>'

    bar_applet("applet", 50) do |wmii, bar|
       bar.on_click(MOUSE_BUTTON_LEFT){ wmii.view "foo" }
       Thread.new{ loop{ bar.data = `somecmd` }; sleep 2 }
    end

    binding("do-magic", "MODKEY-Shift-m", "MODKEY2-m") do |wmii, keyhandler|
      # keyhandler.key is the key that was pressed.
      # you can unregisted the keyhandler (remove the binding) with 
      # wmii.unregister(keyhandler)

      wmii.write "/view/sel/mode", "max"
    end
  end
  
The end-user would have to place the above code in a .rb file under
$HOME/.wmii-3/plugins
and add this to his wmii-config.rb:

  from("my-email@address.com") {
    use_binding("do-magic")  # optionally rebind it to another key
    use_bar_applet("applet") # optionally change position and initial label
  }

or alternatively
  
  use_binding("my-email@address.com:do-magic") 
  use_bar_applet("my-email@addres.com:applet") 


Further information
===================

This should be enough to get you running, but there are still a few things to
be learned from ruby-wmii's sources. You can see how some typical tasks are
implemented in standard-plugin.rb, which contains the default bindings and
applets under the "standard" namespace. 


Happy hacking,

--'
Mauricio Fernandez <mfp@acm.org>  http://eigenclass.org
EOF


END{ "wmiirc #{Process.pid} finishing, $! is #{$!.inspect}" }

def run
  unless File.exist?(WMIIRC_CONFIG_FILE)
    File.open(WMIIRC_CONFIG_FILE, "w"){|f| f.puts DATA.read }
    Thread.new do
      IO.popen("xmessage -file -", "w"){|f| f.puts WMIIRC_HELP_MESSAGE; f.close_write }
    end
  end

  Dir["#{WMIIRC_PLUGIN_DIR}/*.rb"].each do |fname|
    LOGGER.info "Loading plugin #{fname}"
    load fname
  end

  # see if the standard plugin is available
  if Plugin.registered_plugins["standard"].empty?
    Thread.new do
      IO.popen("xmessage -file -", "w") do |f|
        f.puts <<EOF
Could not find the standard plugin, so several bindings/applets 
will be missing.  Please reinstall ruby-wmii, or copy 
standard-plugin.rb (which you will find in the source tarball) to 
$HOME/.wmii-3/plugins.
EOF
        f.close_write
      end
    end
  end
  
  load WMIIRC_CONFIG_FILE

  Thread.abort_on_exception = false

  #{{{ Run START_PROGS
  LOGGER.info "Running START_PROGS:"
  if defined? START_PROGS
    START_PROGS.each{|line| LOGGER.info "Executing #{line}"; system(line)}
  end

  #{{{ Main loop
  LOGGER.info "Executing main loop..."
  WMII::Configuration.last_instance.main_loop
end


require 'logger'
require 'fcntl'

$children = []
logfile = File.open(File.join(WMIIRC_HOME, "wmiirc.log"), "a")
logfile.fcntl Fcntl::F_SETFD, Fcntl::FD_CLOEXEC
DATA.fcntl Fcntl::F_SETFD, Fcntl::FD_CLOEXEC
      
logfile.sync = true
STDOUT.reopen(logfile)
STDERR.reopen(logfile)
LOGGER = Logger.new(STDERR)
LOGGER.info "INIT"

# IXP extension not ready for prime-time
$pure_ruby_ixp_needed = !USE_IXP_EXTENSION 
begin
$:.unshift ENV["HOME"] + "/.wmii-3/ext/IXP"
require 'IXP'
rescue LoadError
  LOGGER.debug "Using wmiir"
  LOGGER.debug "Current dir: #{Dir.pwd}"
  $pure_ruby_ixp_needed = true
end unless $pure_ruby_ixp_needed

module IXP
  if $pure_ruby_ixp_needed
    OWRITE = 1
    IXPError = Class.new(StandardError)
    BrokenPipeError = Class.new(IXPError)
    BusyError = Class.new(IXPError)
    class LowLevelClient
      def initialize(address)
        @address = address
      end

      def write(file, contents, mode = nil) # mode ignored
        IO.popen("wmiir -a #{@address} write #{file}", "w"){|io| io.print contents.to_s; io.close_write }
        true
      rescue Errno::EPIPE
        return false
      end

      def read(file)
        `wmiir -a #{@address} read #{file}`
      end

      def remove(file)
        system("wmiir -a #{@address} remove #{file}")
      end

      def create(file)
        system("wmiir -a #{@address} create #{file}")
      end

      def foreach(file, &block)
        open("|wmiir read #{file}") do |is|
          LOGGER.debug "Executing foreach, using process #{is.pid}"
          $children << is.pid
          is.fcntl Fcntl::F_SETFD, Fcntl::FD_CLOEXEC
          is.each(&block)
        end
        nil
      end

      def fileno
        nil
      end
    end
  end # if $pure_ruby_ixp_needed

  class Client
    attr_reader :address

    def initialize(address)
      @address = address
      establish_connection
    end

    %w[write read remove create].each do |meth|
      define_method(meth) do |*args|
        max_attempts = 10
        begin
          @client.__send__(meth, *args)
        rescue IXP::BrokenPipeError, SystemCallError
          LOGGER.debug "Restablishing connection..."
          establish_connection
          retry if (max_attempts -= 1) > 0
        rescue IXP::IXPError
          return ""
        end
      end
    end

    def foreach(file, &block)
      @client.foreach(file, &block)
    end

    private
    def establish_connection
      LOGGER.debug "Connecting to #{address}"
      @client = LowLevelClient.new(address.clone)
      LOGGER.debug "Connection established (fd #{@client.fileno})" if @client.fileno
    end
  end
end

module WMII
  MOUSE_BUTTON_LEFT = 1
  MOUSE_BUTTON_MIDDLE = 2
  MOUSE_BUTTON_RIGHT = 3
  MOUSE_SCROLL_UP = 4
  MOUSE_SCROLL_DOWN = 5

  module ConfigurationHelper
    def def_conf_var(*names)
      names.each do |name|
        define_method(name) do |*val|
          case val[0]
          when nil:   instance_variable_get("@#{name}")
          else        instance_variable_set("@#{name}", val[0])
          end
        end
      end
    end

    def def_wmii_var(*names, &block)
      names.each do |name|
        define_method(name) do |*val|
          case val[0]
          when nil:  @ixp_conn.read "/def/#{name}"
          else
            @ixp_conn.write "/def/#{name}", val[0]
            block.call val[0] if block
          end
        end
      end
    end
  end

  class Plugin
    class << self
      attr_reader :registered_plugins
      private :new
    end
    @registered_plugins = Hash.new{|h,namespace| h[namespace] = []}

    PluginClashError = Class.new(StandardError)
    KeyBindingClashError = Class.new(PluginClashError)
    BarAppletClashError = Class.new(PluginClashError)
    
    KeyBinding = Struct.new(:keys, :block)
    BarApplet = Struct.new(:position, :initial_data, :block)
    
    def self.define(namespace, &block)
      r = new(namespace)
      r.instance_eval(&block)
      Plugin.registered_plugins[namespace] << r
      r
    end

    attr_reader :bindings
    attr_reader :bar_applets
    def initialize(namespace)
      @namespace = namespace
      @bindings = {}
      @bar_applets = {}
    end
    
    extend ConfigurationHelper
    def_conf_var :author

    def binding(name, *suggested_bindings, &block)
      if @bindings.has_key?(name)
        raise KeyBindingClashError, "Binding #{name} defined twice in namespace #{@namespace.inspect}"
      end
      @bindings[name] = KeyBinding.new(suggested_bindings, block)
    end

    def bar_applet(name, position, initial_data = "", &block)
      if @bar_applets.has_key?(name)
        raise BarAppletClashError, "Bar applet #{name} defined twice in namespace #{@namespace.inspect}"
      end
      @bar_applets[name] = BarApplet.new(position, initial_data, block)
    end
  end

  class Configuration
    DEFAULT_EVENTS = %w[BarClick ClientClick ClientFocus CreateClient Key Bye Starting]
    attr_reader :plugin_config, :prev_view

    class EventHandler
      attr_reader :type

      def initialize(type, &block)
        @type = type
        @block = block
      end

      def call(*a); @block.call(*a) end
    end

    class KeyHandler < EventHandler
      attr_reader :key

      def initialize(key, &block)
        @key = key
        super("Key", &block)
      end
    end

    class PluginConfigHash
      def initialize
        @opts = Hash.new{|h,k| h[k] = {} }
      end
      
      def [](x); @opts[x] end
      def []=(x, val); @opts[x] = val end
    end

    class << self;
      attr_reader :last_instance
      def define(*a, &b)
        r = new(*a, &b)
        @last_instance = r
        r
      end

      private :new
    end

    def initialize(&block)
      # Signal we're about to start to the previous wmiirc process, or wait
      # until the IXP server is up
      LOGGER.info "Waiting for the IXP server."
      begin
        @ixp_conn = IXP::Client.new ENV["WMII_ADDRESS"]
      rescue SystemCallError
        LOGGER.info "IXP server not up yet, waiting..."
        sleep 0.2
        retry
      end
      LOGGER.info "Killing old wmiirc instances."
      loop{ @ixp_conn.write "/event", "Starting\n" and break } # standard wmiirc
      @ixp_conn.write "/event", "Bye\n"         # new-style wmiirc
      @procs = {"BarClick" => [], "ClientClick" => [],
                "ClientFocus" => [], "CreateClient" => [], 
                "Key" => Hash.new{|h,k| h[k] = []}}
      update_custom_handlers_matcher

      @plugin_config = PluginConfigHash.new
      @children = $children
      # reset key bindings
      LOGGER.info "Resetting key bindings."
      @ixp_conn.write "/def/keys", "\n"
      @key_substitutions = {
        "MODKEY" => "Mod1", "UP" => "k", "DOWN" => "j", 
        "LEFT"  => "h", "RIGHT" => "l" 
      }
      @view_history_decay = 0.8
      @view_history_prev_bias = 0.4
      @view_transition_table = Hash.new{|h,k| h[k] = Hash.new{|h2,k2| h2[k2] = 0} }
      @view_transitions = Hash.new{|h,k| h[k] = 0}
      @prev_view = curr_view
      LOGGER.info "Loading configuration"
      instance_eval(&block) if block_given?
    end

    def write(file, contents)
      @ixp_conn.write(file, contents.to_s, IXP::OWRITE)
    end

    def read(file)
      @ixp_conn.read(file)
    end

    def remove(file)
      @ixp_conn.remove(file)
    end

    def create(file)
      @ixp_conn.create(file)
    end

    def update_custom_handlers_matcher
      @custom_handlers_re = /^#{(@procs.keys - DEFAULT_EVENTS).join("|")}(\s|$)/
    end

    private :update_custom_handlers_matcher
    def from(namespace, &block)
      conf = self
      Class.new do
        define_method(:use_binding) do |name, *overriding_keys|
          conf.use_binding("#{namespace}:#{name}", *overriding_keys)
        end
        define_method(:use_bar_applet) do |name, *opts|
          conf.use_bar_applet("#{namespace}:#{name}", *opts)
        end
      end.new.instance_eval(&block)
    end
    
    def use_binding(binding_name, *overriding_keys)
      md = /([^:]+):(.+)/.match(binding_name)
      unless md
        LOGGER.error "Ignoring illegal binding name #{binding_name}."
        return
      end
      namespace, name = md.captures
      if (plugins = Plugin.registered_plugins[namespace]).empty?
        LOGGER.error "Unknown plugin #{namespace}"
        return
      end
      key_bindings = plugins.inject([]){|s,x| s + [x.bindings[name]]}.compact
      if key_bindings.empty?
        LOGGER.error "Key binding #{name} not found in #{namespace}."
        return
      end
      if key_bindings.size > 1
        LOGGER.debug "Key binding #{name} defined more than once in #{namespace}."
        LOGGER.debug "Keeping last definition."
      end
      key_binding = key_bindings.last
      keys, block = key_binding.keys, key_binding.block
      actual_keys = overriding_keys.empty? ? keys : overriding_keys
      LOGGER.info "Importing key binding #{namespace}:#{name} as #{actual_keys.join(' ')}"
      on_key(*actual_keys, &block)
    end
    
    def use_bar_applet(bar_applet_name, position = nil, data = nil) 
      md = /([^:]+):(.+)/.match(bar_applet_name)
      unless md
        LOGGER.error "Ignoring illegal applet name #{bar_applet_name}."
        return
      end
      namespace, name = md.captures
      if (plugins = Plugin.registered_plugins[namespace]).empty?
        LOGGER.error "Unknown plugin #{namespace}"
        return
      end
      bar_applets = plugins.inject([]){|s,x| s + [x.bar_applets[name]]}.compact
      if bar_applets.empty?
        LOGGER.error "Bar applet #{name} not found in #{namespace}."
        return
      end
      if bar_applets.size > 1
        LOGGER.debug "Bar applet #{name} defined more than once in #{namespace}."
        LOGGER.debug "Keeping last definition."
      end
      bar_applet = bar_applets.last

      position = position || bar_applet.position
      initial_data = data || bar_applet.initial_data
      block = bar_applet.block
      
      LOGGER.info "Importing bar applet #{namespace}:#{name} at position #{position}"
      setup_bar("%03d_#{name}" % position, normcolors, initial_data, &block)
    end

    def register(type, param1 = nil, param2 = nil, &block)
      case param1
      when nil
        handler = EventHandler.new(type, &block)
      else
        handler = EventHandler.new(type) do |*args|
          if param1 === args[0] && (!param2 || param2 === args[1])
            block.call(*args)
          end
        end
      end
      (@procs[type] ||= []) << handler

      update_custom_handlers_matcher

      handler
    end

    def unregister(handler)
      case handler
      when KeyHandler
        @procs["Key"][handler.key].delete handler
      else
        @procs[handler.type].delete handler
      end
      update_custom_handlers_matcher
    end


    def register_key_bindings
      LOGGER.info "Setting /def/keys"
      @ixp_conn.write "/def/keys", @procs["Key"].keys.join("\n")
    end

    def main_loop
      @ixp_conn.write "/event", "Bye\n"
      register_key_bindings
      loop do 
        begin
          # wait for events
          LOGGER.debug "Opening /event"
          i = 0
          IXP::Client.new(ENV["WMII_ADDRESS"]).foreach("/event") do |line|
            begin
              LOGGER.debug "Got #{line.inspect}" if line
              case line
              when /^(BarClick|ClientClick)\s+(\S+)\s+(\S+)$/
                @procs[$1].each{|x| x.call($2, $3.to_i)}
              when /^(ClientFocus|CreateClient)\s+(\S+)/
                @procs[$1].each{|x| x.call($2.to_i)}
              when /^Key (\S+)$/
                @procs["Key"][$1].each{|x| x.call(self, x)} if @procs["Key"].has_key?($1)
              when /^Bye|^Starting/
                LOGGER.info "Cleanup..."
                cleanup
                LOGGER.info "QUIT"
                exit!
              when @custom_handlers_re
                event, *args = *line.chomp.split(/\s/)
                LOGGER.debug "Custom event #{event}"
                @procs[event].each{|x| x.call(*args)}
              end
            rescue IOError, SystemCallError
              # terminate #foreach
              raise
            rescue StandardError => e
              LOGGER.debug e.inspect
              LOGGER.debug e.message
              e.backtrace.each{|x| LOGGER.debug x}
            end
          end
        rescue IXP::BusyError
          # this is a child process, it must die ASAP
          LOGGER.debug "child process #{Process.pid} exiting."
          exit!
        rescue Exception
          # ignore
          LOGGER.debug "Ignoring #{$!.inspect}"
        end
      end
    end

    # not worth meta-programming 
    def on_barclick(name = nil, button = nil, &b)
      register("BarClick", name, button, &b)
    end

    def on_clientclick(client = nil, button = nil, &b)
      register("ClientClick", client, button, &b)
    end

    def on_clientfocus(client = nil, &b); register("ClientFocus", client, &b) end
    def on_createclient(client = nil, &b); register("CreateClient", client, &b) end

    def on_key(*aliasedkeys, &block)
      handlers = []
      aliasedkeys.each do |aliasedkey|
        key = aliasedkey.clone
        handler = KeyHandler.new(key, &block)
        @key_substitutions.sort_by{|kalias, actual| kalias.size}.reverse.each do |kalias, val|
          key.gsub!(/\b#{Regexp.escape(kalias)}\b/, val)
        end
        
        LOGGER.info "Registering #{aliasedkey} => #{key}."
        @procs["Key"][key] << handler
        handlers << handler
      end

      return *handlers
    end

    def clean_fork(&b)
      @children << fork(&b)
      Process.detach @children.last
      LOGGER.debug "clean_fork(): #{@children.last}"
    end

    def cleanup
      LOGGER.debug "This is #{Process.pid}, killing #{@children.inspect}"
      @children.each do |pid|
        begin
          Process.kill("TERM", pid)
        rescue Exception
        end
      end
    end

    ####{{{ Configuration methods
    extend ConfigurationHelper
    def_conf_var :view_history_decay
    def_conf_var :view_history_prev_bias
    
    def_wmii_var :border, :colmode, :colwidth, :rules, :grabmod
    def_wmii_var(:selcolors){|colors| ENV["WMII_SELCOLORS"] = colors.to_s }
    def_wmii_var(:normcolors){|colors| ENV["WMII_NORMCOLORS"] = colors.to_s }
    def_wmii_var(:font){|font| ENV["WMII_FONT"] = font.to_s }

    def key_subs(associations)
      unless Hash === associations
        raise ArgumentError, 
          "key_subs takes a hash with  alias => actual_key  associations"
      end
      associations.each_pair do |key, val|
        @key_substitutions[key.to_s] = val.to_s
      end
    end
 
    class BarButton
      attr_reader :name
      def initialize(wmiiconfig, name)
        @wmiiconfig = wmiiconfig
        @name = name
      end

      def on_click(key = nil, &block)
        raise "block wanted" unless block
        @wmiiconfig.on_barclick(name, key, &block)
      end

      def data;     @wmiiconfig.read("/bar/#{@name}/data") end
      def data=(x); @wmiiconfig.write("/bar/#{@name}/data", x) end
    end
    
    # convenience methods
    def setup_bar(name, colors = normcolors, data = "", &block)
      LOGGER.info "Setting up bar applet #{name}"
      @ixp_conn.remove "/bar/#{name}" rescue nil
      @ixp_conn.create "/bar/#{name}"
      @ixp_conn.write "/bar/#{name}/colors", colors
      @ixp_conn.write "/bar/#{name}/data", data.chomp
      if block_given?
        yield self, BarButton.new(self, name)
      end
    end

    def normalize(tags)
      tags = tags.split(/\+/) unless Array === tags
      tags.map{|x| x.chomp}.sort.uniq.compact.grep(/./).join("+")
    end

    def views
      @ixp_conn.read("/tags").split(/\n/).grep(/./)
    end

    def views_intellisort
      views.sort.sort_by do |view|
        curr = curr_view
        if @view_transition_table[curr].has_key?(view)
          prob = @view_transition_table[curr][view]
          prob = [prob, @view_history_prev_bias].max if view == @prev_view
          [0, - prob, view]   # handle ties
        elsif view == @prev_view
          [0, -@view_history_prev_bias, view]
        else
          [1, 0, view]
        end
      end
    end

    def curr_view
      @ixp_conn.read("/view/name").chomp
    end

    def set_curr_view(viewname)
      viewname = viewname.to_s.chomp
      return unless views.include? viewname
      LOGGER.info("Switching to #{viewname.inspect}")
      @prev_view = curr_view
      @ixp_conn.write "/ctl", "view #{viewname}"
      n_trans = (@view_transitions[@prev_view] += 1)
      table = @view_transition_table[@prev_view]
      table.each_pair do |key, val|
        table[key] = val * @view_history_decay *  n_trans / (n_trans + 1)
      end
      table[viewname] += (1.0 - @view_history_decay) + 1.0 / (n_trans + 1)
      total = table.values.inject{|s,x| s+x}
      table.each_key{|k| table[k] /= total }
      LOGGER.debug "Trans. table (order 1): #{@view_transition_table.inspect}"
    end
    alias_method :curr_view=, :set_curr_view
    alias_method :view, :set_curr_view

    def curr_view_index
      views.index(curr_view)
    end

    def curr_client_tags
      @ixp_conn.read("/view/sel/sel/tags").split(/\+/).reject{|x| x.empty?}.compact.uniq.sort
    end

    def curr_client_tags=(tags)
      @ixp_conn.write("/view/sel/sel/tags", normalize(tags))
    end
    
    alias_method :set_curr_client_tags, :curr_client_tags=

    def retag_curr_client(new_tag)
      return if /^\s*$/ =~ new_tag
      old_tags = curr_client_tags
      new_tags = case new_tag
      when /^\+/ :  old_tags + [new_tag[1..-1]]
      when /^-/  :  old_tags - [new_tag[1..-1]]
      else          [new_tag]
      end
      new_tags = normalize(new_tags)

      LOGGER.info "Retagging #{old_tags.inspect} => #{new_tags.inspect})"
      set_curr_client_tags  new_tags
    end

    def retag_curr_client_ns(new_tag)
      return if /^\s*$/ =~ new_tag

      old_tags = curr_client_tags
      namespace = old_tags.reject{|x| /^\d+$|:/ =~ x}.last
      new_tags = case new_tag
      when /^\+/ : old_tags + ["#{namespace}:#{new_tag[1..-1]}"]
      when /^\-/ : old_tags - ["#{namespace}:#{new_tag[1..-1]}"]
      else         ["#{namespace}:#{new_tag}"]
      end

      set_curr_client_tags new_tags
    end

    def wmiimenu(options, &block)
      rd, wr = IO.pipe
      rd.fcntl Fcntl::F_SETFD, Fcntl::FD_CLOEXEC
      wr.fcntl Fcntl::F_SETFD, Fcntl::FD_CLOEXEC
      Thread.new do
        pid = fork do 
          rd.close
          chosen = IO.popen("wmiimenu", "r+") do |f|
            f.puts options
            f.close_write
            f.read
          end.chomp
          LOGGER.debug "wmiimenu(#{chosen.inspect}) finished"
          begin
            wr.print chosen
            wr.close
          rescue Exception # catch EPIPE etc.
          end
          yield chosen if block_given?
          exit!
        end
        Process.wait(pid)
      end
      wr.close
      def rd.value; ret = (gets||"").chomp; close; ret end
      rd
    end

    def program_list
      @__program_list_last_update ||= Time.at(0)
      @__program_list ||= []
      path_glob = ENV["PATH"].gsub(/,/, '\\,').tr(":",",")
      return @__program_list if Time.new - @__program_list_last_update < 3600
      @__program_list_last_update = Time.new
      @__program_list = Dir.glob("{#{path_glob}}/*").select do |fname|
        File.file?(fname) && File.executable?(fname)
      end.map{|fname| File.basename(fname)}.sort.uniq
    end

    def action_list
      Dir["#{WMIIRC_HOME}/*"].select do |f|
        File.file?(f) && File.executable?(f)
      end.map{|f| File.basename(f)}.sort.uniq
    end

    def condition(&block)
      c = lambda(&block)
      def c.===(*x); call(*x) end
      c
    end
  end # Configuration

end # WMII

include WMII

run

__END__
# {{{ ======== ruby-wmii CONFIGURATION BEGINS HERE ==============

# programs to run when wmiirc starts
# one per line, they're run sequentially right before the main loop begins
START_PROGS = <<EOF
xsetroot -solid '#333333'
EOF

# {{{ WM CONFIGURATION
WMII::Configuration.define do
  border      1
  font        "fixed"
  selcolors   '#FFFFFF #248047 #147027'
  normcolors  '#4D4E4F #DDDDAA #FFFFCC'
  colmode     'default'
  colwidth    0
  grabmod     'Mod1'
  rules <<EOF
/Kdict.*/ -> dict
/XMMS.*/ -> ~
/Gimp.*/ -> ~
/MPlayer.*/ -> ~
/XForm.*/ -> ~
/XSane.*/ -> ~
/fontforge.*/ -> ~
/.*/ -> !
/.*/ -> 1
EOF

  # Translate the following names in the on_key and use_binding definitions.
  key_subs  :MODKEY  => :Mod1,
            :MODKEY2 => :Mod4,
            :LEFT    => :h,
            :RIGHT   => :l,
            :UP      => :k,
            :DOWN    => :j


  # Constant used by the intellisort tag selection mechanism
  # set it to   0.0 <= value <= 1.0
  # Lower values make recent choices more likely (modified first order
  # markovian process with exponential decay):
  # 0.0 means that only the last transition counts (all others forgotten)
  # 1.0 means that the probabilities aren't biased to make recent choices more
  #     likely
  view_history_decay 0.8

  # Favor the view we came from in intellisort.
  # 1.0: that view is the first choice
  # 0.0: that view comes after all views with non-zero transition probability,
  #      but before all views we haven't yet jumped to from the current one
  view_history_prev_bias 0.4

# {{{ Plugin config
  
  # Uncomment and change to override default on_click actions for the status
  # bar
  #plugin_config["standard:status"]["left_click_action"] = lambda{ system "xeyes" }
  #plugin_config["standard:status"]["right_click_action"] = lambda{ system "xeyes" }
  #plugin_config["standard:status"]["middle_click_action"] = lambda{ system "xeyes" }
  
  plugin_config["standard:status"]["refresh_time"] = 1
  
  # Uncomment and change to override default text
  #currload = nil
  #Thread.new{ loop { currload = `uptime`.chomp.sub(/.*: /,"").gsub(/,/,""); sleep 10 } }
  #plugin_config["standard:status"]["text_proc"] = lambda do
  #  "#{Time.new.strftime("%d/%m/%Y %X %Z")} #{currload}"
  #end

  plugin_config["standard"]["x-terminal-emulator"] = "x-terminal-emulator"

  plugin_config["standard:actions"]["history_size"] = 3  # set to 0 to disable
  plugin_config["standard:programs"]["history_size"] = 5 # set to 0 to disable

  plugin_config["standard:volume"]["mixer"] = "Master"
  
  plugin_config["standard:mode"]["mode_toggle_keys"] = ["MODKEY2-space"]

  plugin_config["standard:battery-monitor"]["statefile"] = 
      '/proc/acpi/battery/BAT0/state'
  plugin_config["standard:battery-monitor"]["infofile"] =
      '/proc/acpi/battery/BAT0/info'
  plugin_config["standard:battery-monitor"]["low"] = 5
  plugin_config["standard:battery-monitor"]["low_action"] =
      'echo "Low battery" | xmessage -center -buttons quit:0 -default quit -file -'
  plugin_config["standard:battery-monitor"]["critical"] = 1
  plugin_config["standard:battery-monitor"]["critical_action"] =
      'echo "Critical battery" | xmessage -center -buttons quit:0 -default quit -file -'

  
  # Allows you to override the default internal actions and define new ones:
  #plugin_config["standard:actions"]["internal"] = {
  #  "screenshot" => nil,    # remove default screenshot action
  #  "google" => lambda do |wmii, *selection|
  #    require 'cgi'
  #    if selection && !selection.empty?
  #      selection = CGI.escape(selection.join(" "))
  #    else
  #      selection = CGI.escape(%!#{`wmiipsel`.strip}!)
  #    end
  #    url = "http://www.google.com/search?q=#{selection}"
  #    case browser = ENV["BROWSER"]
  #    when nil: system "wmiisetsid /etc/alternatives/x-www-browser '#{url}' &"
  #    else system "wmiisetsid #{browser} '#{url}' &"
  #    end
  #  end,
  #  "foo" => lambda do |wmii, *args|
  #    IO.popen("xmessage -file -", "w"){|f| f.puts "Args: #{args.inspect}"; f.close_write }
  #  end
  #}

#{{{ Import bindings and bar applets
  from "standard"  do
    use_bar_applet "volume", 999
    use_bar_applet "mode", 900
    use_bar_applet "status", 100
    #use_bar_applet "cpuinfo", 150
    #use_bar_applet "mpd", 110
    #use_bar_applet "battery-monitor

    use_binding "dict-lookup"
    use_binding "execute-program-with-tag"
    use_binding "execute-action"
    use_binding "execute-program"
    (0..9).each{|k| use_binding "numeric-jump-#{k}"  }
    use_binding "tag-jump"
    use_binding "retag"
    use_binding "retag-jump"
    use_binding "namespace-retag"
    use_binding "namespace-retag-jump"
    ('a'..'z').each{|k| use_binding "letter-jump-#{k}" }
    (0..9).each{|k| use_binding "numeric-retag-#{k}" }
    use_binding "move-prev"
    use_binding "move-next"
    use_binding "namespace-move-prev"
    use_binding "namespace-move-next"
  end

  # {{{ Click on view bars
  on_barclick(/./, MOUSE_BUTTON_LEFT){|name,| view name}
  on_barclick(/./, MOUSE_BUTTON_RIGHT){|name,| view name}

  # {{{ Tag all browser instances as 'web' in addition to the current tag
  browsers = %w[Firefox Konqueror]
  browser_re = /^#{browsers.join("|")}/
  on_createclient(condition{|c| browser_re =~ read("/client/#{c}/class")}) do |cid|
    write("/client/#{cid}/tags", normalize(read("/client/#{cid}/tags") + "+web"))
  end

#{{{ Simpler key bindings --- not defined in plugins
  on_key("MODKEY-LEFT"){ write "/view/ctl", "select prev" }
  on_key("MODKEY-RIGHT"){ write "/view/ctl", "select next" }
  on_key("MODKEY-DOWN"){ write "/view/sel/ctl", "select next" }
  on_key("MODKEY-UP"){ write "/view/sel/ctl", "select prev" }
  on_key("MODKEY-space"){ write "/view/ctl", "select toggle" }
  on_key("MODKEY-d"){ write "/view/sel/mode", "default" }
  on_key("MODKEY-s"){ write "/view/sel/mode", "stack" }
  on_key("MODKEY-m"){ write "/view/sel/mode", "max" }
  on_key("MODKEY-f"){ write "/view/0/sel/geom", "0 0 east south" }
  on_key("MODKEY-i"){ write "/view/sel/sel/geom", "+0 +0 +0 +48" }
  on_key("MODKEY-Shift-i"){ write "/view/sel/sel/geom", "+0 +0 +0 -48" }
  on_key("MODKEY-Return") do 
    term = plugin_config["standard"]["x-terminal-emulator"] || "xterm"
    system "wmiisetsid #{term} &"
  end
  on_key("MODKEY-Shift-LEFT"){ write "/view/sel/sel/ctl", "sendto prev" }
  on_key("MODKEY-Shift-RIGHT"){ write "/view/sel/sel/ctl", "sendto next" }
  on_key("MODKEY-Shift-DOWN"){ write "/view/sel/sel/ctl", "swap down" }
  on_key("MODKEY-Shift-UP"){ write "/view/sel/sel/ctl", "swap up" }
  on_key("MODKEY-Shift-space"){ write "/view/sel/sel/ctl", "sendto toggle" }
  on_key("MODKEY-Shift-c"){ write "/view/sel/sel/ctl", "kill" }
  on_key("MODKEY-r"){ view prev_view }
  on_key("MODKEY-Control-LEFT") { write "/view/sel/sel/ctl", "swap prev" }
  on_key("MODKEY-Control-RIGHT"){ write "/view/sel/sel/ctl", "swap next" }

  
# {{{ ======== CONFIGURATION ENDS HERE ==============
end
